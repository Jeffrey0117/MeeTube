/**
 * API Routes
 * YouTube API endpoints
 */

import { Router } from 'express'
import {
  getInnertube,
  getInnertubeAndroid,
  convertSearchResults,
  convertVideoInfo,
  convertChannelVideos,
  createAuthorThumbnails,
  toGgphtProxyUrl,
  toProxyUrl,
} from '../services/youtube.js'

const router = Router()

// Search
router.get('/search', async (req, res) => {
  try {
    const q = req.query.q || ''
    const innertube = getInnertube()
    const results = await innertube.search(q)
    const converted = convertSearchResults(results.results || [])
    res.json(converted)
  } catch (error) {
    console.error('[SEARCH]', error.message)
    res.status(500).json({ error: error.message })
  }
})

// Search suggestions
router.get('/search/suggestions', async (req, res) => {
  try {
    const q = req.query.q || ''
    const innertube = getInnertube()
    const suggestions = await innertube.getSearchSuggestions(q)
    res.json({ query: q, suggestions })
  } catch (error) {
    console.error('[SUGGESTIONS]', error.message)
    res.status(500).json({ error: error.message })
  }
})

// Video info
router.get('/videos/:id', async (req, res) => {
  try {
    const videoId = req.params.id
    console.log(`[VIDEO] Fetching: ${videoId}`)

    const innertubeAndroid = getInnertubeAndroid()
    const innertube = getInnertube()

    // Use Android client for streams
    const info = await innertubeAndroid.getBasicInfo(videoId)

    // Use regular client for related videos
    let relatedVideos = []
    let channelAvatar = null

    try {
      const fullInfo = await innertube.getInfo(videoId)
      relatedVideos = fullInfo.watch_next_feed || []
      console.log(`[VIDEO] Found ${relatedVideos.length} related videos`)

      const secondaryInfo = fullInfo.secondary_info
      if (secondaryInfo?.owner?.author?.thumbnails?.[0]?.url) {
        channelAvatar = secondaryInfo.owner.author.thumbnails[0].url
      }
    } catch (e) {
      console.log(`[VIDEO] Could not get related videos: ${e.message}`)
    }

    const converted = await convertVideoInfo(info, relatedVideos, channelAvatar)
    res.json(converted)
  } catch (error) {
    console.error('[VIDEO]', error.message)
    res.status(500).json({ error: error.message })
  }
})

// Channel info
router.get('/channels/:id', async (req, res) => {
  try {
    const channelId = req.params.id
    console.log(`[CHANNEL] Fetching: ${channelId}`)

    const innertube = getInnertube()
    const channel = await innertube.getChannel(channelId)

    const metadata = channel.metadata || {}

    // Available tabs
    const tabs = []
    if (channel.has_videos) tabs.push('videos')
    if (channel.has_shorts) tabs.push('shorts')
    if (channel.has_live_streams) tabs.push('live')
    if (channel.has_playlists) tabs.push('playlists')
    if (channel.has_community) tabs.push('community')
    tabs.push('about')

    // Avatar
    const avatarUrl = metadata.avatar?.[0]?.url || ''
    const authorThumbnails = createAuthorThumbnails(avatarUrl)

    // Banner
    const bannerUrl = metadata.banner?.[0]?.url || ''
    const authorBanners = bannerUrl ? [
      { url: toGgphtProxyUrl(bannerUrl), width: 1280, height: 720 }
    ] : []

    // Subscriber count
    let subCount = 0
    const subText = metadata.subscriber_count || ''
    if (subText) {
      const match = subText.match(/([\d.]+)\s*([KMB萬億])?/i)
      if (match) {
        let num = parseFloat(match[1])
        const unit = (match[2] || '').toUpperCase()
        if (unit === 'K' || unit === '萬') num *= 1000
        else if (unit === 'M' || unit === '億') num *= 1000000
        else if (unit === 'B') num *= 1000000000
        subCount = Math.floor(num)
      }
    }

    // Latest videos
    let latestVideos = []
    try {
      if (channel.has_videos) {
        const videosTab = await channel.getVideos()
        latestVideos = convertChannelVideos(videosTab.videos || [], channelId)
      }
    } catch (e) {
      console.log(`[CHANNEL] Could not fetch latest videos: ${e.message}`)
    }

    res.json({
      author: metadata.title || '',
      authorId: channelId,
      authorUrl: `/channel/${channelId}`,
      authorVerified: false,
      authorBanners: authorBanners,
      authorThumbnails: authorThumbnails,
      subCount: subCount,
      totalViews: 0,
      joined: 0,
      autoGenerated: false,
      isFamilyFriendly: metadata.is_family_safe ?? true,
      description: metadata.description || '',
      descriptionHtml: metadata.description || '',
      allowedRegions: [],
      tabs: tabs,
      latestVideos: latestVideos,
      relatedChannels: [],
    })
  } catch (error) {
    console.error('[CHANNEL]', error.message)
    res.status(500).json({ error: error.message })
  }
})

// Channel sub-resources
router.get('/channels/:id/:subResource', async (req, res) => {
  try {
    const { id: channelId, subResource } = req.params
    console.log(`[CHANNEL] Fetching ${subResource} for: ${channelId}`)

    const innertube = getInnertube()
    const channel = await innertube.getChannel(channelId)

    let data = { videos: [], continuation: null }

    switch (subResource) {
      case 'videos': {
        const videosTab = await channel.getVideos()
        data = {
          videos: convertChannelVideos(videosTab.videos || [], channelId),
          continuation: videosTab.has_continuation ? 'has_more' : null
        }
        break
      }
      case 'shorts': {
        if (channel.has_shorts) {
          const shortsTab = await channel.getShorts()
          const videos = (shortsTab.videos || []).map(video => {
            const videoId = video.id
            if (!videoId) return null
            return {
              type: 'video',
              title: video.title?.text || '',
              videoId: videoId,
              authorId: channelId,
              authorUrl: `/channel/${channelId}`,
              videoThumbnails: [
                { quality: 'maxres', url: `/vi/${videoId}/maxresdefault.jpg`, width: 1280, height: 720 },
              ],
              viewCountText: video.views?.text || '',
              lengthSeconds: 60,
            }
          }).filter(Boolean)
          data = { videos, continuation: shortsTab.has_continuation ? 'has_more' : null }
        }
        break
      }
      case 'playlists': {
        if (channel.has_playlists) {
          const playlistsTab = await channel.getPlaylists()
          const playlists = (playlistsTab.playlists || []).map(playlist => ({
            type: 'playlist',
            title: playlist.title?.text || '',
            playlistId: playlist.id,
            playlistThumbnail: `/vi/${playlist.first_video_id}/mqdefault.jpg`,
            author: channel.metadata?.title || '',
            authorId: channelId,
            videoCount: playlist.video_count || 0,
          }))
          data = { playlists, continuation: playlistsTab.has_continuation ? 'has_more' : null }
        }
        break
      }
      case 'community':
      case 'posts': {
        if (channel.has_community) {
          const communityTab = await channel.getCommunity()
          const channelName = channel.metadata?.title || ''
          const channelAvatar = channel.metadata?.avatar?.[0]?.url || ''

          const posts = (communityTab.posts || []).map(post => ({
            author: channelName,
            authorId: channelId,
            authorThumbnails: createAuthorThumbnails(channelAvatar),
            authorUrl: `/channel/${channelId}`,
            commentId: post.id || '',
            content: post.content?.text || '',
            contentHtml: post.content?.text || '',
            likeCount: 0,
            publishedText: post.published?.text || '',
            replyCount: 0,
            attachment: null,
          }))
          data = { comments: posts, continuation: communityTab.has_continuation ? 'has_more' : null }
        }
        break
      }
      case 'live':
      case 'streams': {
        if (channel.has_live_streams) {
          const liveTab = await channel.getLiveStreams()
          data = {
            videos: convertChannelVideos(liveTab.videos || [], channelId),
            continuation: liveTab.has_continuation ? 'has_more' : null
          }
        }
        break
      }
      default:
        return res.status(404).json({ error: `Unknown sub-resource: ${subResource}` })
    }

    res.json(data)
  } catch (error) {
    console.error('[CHANNEL SUB]', error.message)
    res.status(500).json({ error: error.message })
  }
})

// Trending / Popular
router.get(['/trending', '/popular'], async (req, res) => {
  try {
    const innertube = getInnertube()
    const trending = await innertube.getTrending()
    const converted = convertSearchResults(trending.videos || [])
    res.json(converted)
  } catch (error) {
    console.log('[TRENDING] getTrending failed, using search fallback')
    try {
      const innertube = getInnertube()
      const searchResults = await innertube.search('music video 2024', { sort_by: 'view_count' })
      const converted = convertSearchResults(searchResults.results || [])
      res.json(converted)
    } catch (searchError) {
      console.error('[TRENDING]', searchError.message)
      res.status(500).json({ error: 'Unable to fetch trending videos' })
    }
  }
})

// DASH Manifest
router.get('/manifest/dash/id/:id', async (req, res) => {
  try {
    const videoId = req.params.id
    console.log(`[DASH] Generating manifest for: ${videoId}`)

    const innertubeAndroid = getInnertubeAndroid()
    const info = await innertubeAndroid.getBasicInfo(videoId)
    const streaming = info.streaming_data

    if (!streaming || !streaming.adaptive_formats) {
      console.error(`[DASH] No streaming data for video: ${videoId}`)
      return res.status(404).send('No streaming data available')
    }

    // Filter out formats without URL or range data
    const validFormats = streaming.adaptive_formats.filter(f => {
      if (!f.url) {
        console.warn(`[DASH] Skipping format ${f.itag}: no URL`)
        return false
      }
      return true
    })

    if (validFormats.length === 0) {
      console.error(`[DASH] No valid formats for video: ${videoId}`)
      return res.status(404).send('No valid streaming formats')
    }

    console.log(`[DASH] Found ${validFormats.length} valid formats for ${videoId}`)

    // Get base URL for absolute URLs in manifest
    const protocol = req.get('x-forwarded-proto') || req.protocol || 'http'
    const host = req.get('host')
    const baseUrl = `${protocol}://${host}`

    const manifest = generateDashManifest(videoId, validFormats, info.basic_info?.duration || 0, baseUrl)

    res.set('Content-Type', 'application/dash+xml')
    res.set('Cache-Control', 'no-cache')
    res.set('Access-Control-Allow-Origin', '*')
    res.send(manifest)
  } catch (error) {
    console.error('[DASH]', error.message, error.stack)
    res.status(500).send('Error generating manifest')
  }
})

// Storyboards (placeholder)
router.get('/storyboards/:id', (req, res) => {
  res.json({ storyboards: [] })
})

// Stats (health check)
router.get('/stats', (req, res) => {
  res.json({
    version: '1.0.0',
    software: { name: 'meetube', version: '1.0.0' },
    openRegistrations: true,
    usage: { users: { total: 1, activeHalfyear: 1, activeMonth: 1 } },
  })
})

// === Helper Functions ===

function generateDashManifest(videoId, adaptiveFormats, duration, baseUrl = '') {
  const durationSeconds = duration || 0
  const durationISO = `PT${Math.floor(durationSeconds / 3600)}H${Math.floor((durationSeconds % 3600) / 60)}M${durationSeconds % 60}S`

  const videoFormats = adaptiveFormats.filter(f => f.mime_type?.startsWith('video/'))
  const audioFormats = adaptiveFormats.filter(f => f.mime_type?.startsWith('audio/'))

  function getRange(format, type) {
    const rangeKey = type === 'init' ? 'init_range' : 'index_range'
    const shortKey = type === 'init' ? 'init' : 'index'

    if (format[rangeKey]?.start !== undefined) {
      return `${format[rangeKey].start}-${format[rangeKey].end}`
    }
    if (format[shortKey]) {
      return format[shortKey]
    }
    // If no range data, return null to indicate unavailable
    return null
  }

  function escapeXml(str) {
    if (!str) return ''
    return str
      .replace(/&/g, '&amp;')
      .replace(/</g, '&lt;')
      .replace(/>/g, '&gt;')
      .replace(/"/g, '&quot;')
      .replace(/'/g, '&apos;')
  }

  // Helper to build representation XML
  function buildRepresentation(format, isVideo) {
    const proxyUrl = toProxyUrl(format.url)
    // Use absolute URL for better compatibility
    const url = baseUrl ? `${baseUrl}${proxyUrl}` : proxyUrl
    const codecs = format.mime_type?.match(/codecs="([^"]+)"/)?.[1] || ''
    const initRange = getRange(format, 'init')
    const indexRange = getRange(format, 'index')

    // Skip format if missing critical range data
    if (!initRange || !indexRange) {
      console.warn(`[DASH] Format ${format.itag} missing range data, skipping`)
      return ''
    }

    if (isVideo) {
      const frameRate = format.fps ? ` frameRate="${format.fps}"` : ''
      return `
        <Representation id="${format.itag}" bandwidth="${format.bitrate || 0}" width="${format.width || 0}" height="${format.height || 0}" codecs="${codecs}"${frameRate}>
          <BaseURL>${escapeXml(url)}</BaseURL>
          <SegmentBase indexRange="${indexRange}">
            <Initialization range="${initRange}"/>
          </SegmentBase>
        </Representation>`
    } else {
      const audioSampleRate = format.audio_sample_rate ? ` audioSamplingRate="${format.audio_sample_rate}"` : ''
      return `
        <Representation id="${format.itag}" bandwidth="${format.bitrate || 0}" codecs="${codecs}"${audioSampleRate}>
          <BaseURL>${escapeXml(url)}</BaseURL>
          <SegmentBase indexRange="${indexRange}">
            <Initialization range="${initRange}"/>
          </SegmentBase>
        </Representation>`
    }
  }

  let adaptationSets = ''

  // Video formats by container type
  const mp4Video = videoFormats.filter(f => f.mime_type?.includes('video/mp4'))
  const webmVideo = videoFormats.filter(f => f.mime_type?.includes('video/webm'))

  if (mp4Video.length > 0) {
    const representations = mp4Video.map(f => buildRepresentation(f, true)).filter(Boolean).join('')
    if (representations) {
      adaptationSets += `
    <AdaptationSet mimeType="video/mp4" subsegmentAlignment="true" startWithSAP="1">
      ${representations}
    </AdaptationSet>`
    }
  }

  if (webmVideo.length > 0) {
    const representations = webmVideo.map(f => buildRepresentation(f, true)).filter(Boolean).join('')
    if (representations) {
      adaptationSets += `
    <AdaptationSet mimeType="video/webm" subsegmentAlignment="true" startWithSAP="1">
      ${representations}
    </AdaptationSet>`
    }
  }

  // Audio formats by container type
  const mp4Audio = audioFormats.filter(f => f.mime_type?.includes('audio/mp4'))
  const webmAudio = audioFormats.filter(f => f.mime_type?.includes('audio/webm'))

  if (mp4Audio.length > 0) {
    const representations = mp4Audio.map(f => buildRepresentation(f, false)).filter(Boolean).join('')
    if (representations) {
      adaptationSets += `
    <AdaptationSet mimeType="audio/mp4" subsegmentAlignment="true" startWithSAP="1">
      ${representations}
    </AdaptationSet>`
    }
  }

  if (webmAudio.length > 0) {
    const representations = webmAudio.map(f => buildRepresentation(f, false)).filter(Boolean).join('')
    if (representations) {
      adaptationSets += `
    <AdaptationSet mimeType="audio/webm" subsegmentAlignment="true" startWithSAP="1">
      ${representations}
    </AdaptationSet>`
    }
  }

  // Ensure we have at least one adaptation set
  if (!adaptationSets.trim()) {
    console.error('[DASH] No valid adaptation sets generated')
    throw new Error('No valid adaptation sets')
  }

  return `<?xml version="1.0" encoding="UTF-8"?>
<MPD xmlns="urn:mpeg:dash:schema:mpd:2011" profiles="urn:mpeg:dash:profile:isoff-on-demand:2011" type="static" mediaPresentationDuration="${durationISO}" minBufferTime="PT1.5S">
  <Period duration="${durationISO}">
    ${adaptationSets}
  </Period>
</MPD>`
}

export default router
